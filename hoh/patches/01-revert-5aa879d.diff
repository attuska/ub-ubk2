diff -Naur HeadOverHeels-f6940c2/src/gui/Label.cpp HeadOverHeels-e1d7ade/src/gui/Label.cpp
--- HeadOverHeels-f6940c2/src/gui/Label.cpp	2018-02-26 21:49:49.000000000 +0100
+++ HeadOverHeels-e1d7ade/src/gui/Label.cpp	2018-02-26 22:30:07.000000000 +0100
@@ -2,6 +2,7 @@
 #include "Label.hpp"
 #include "Screen.hpp"
 #include "FontManager.hpp"
+#include "Font.hpp"
 #include "Action.hpp"
 
 
@@ -9,30 +10,49 @@
 {
 
 Label::Label( const std::string& text )
-: Widget( ),
+: Widget( 0, 0 ),
         text( text ),
         fontName( "regular" ),
         color( "white" ),
         font( 0 ),
-        spacing( 0 ),
         buffer( 0 ),
         myAction( 0 )
 {
-        this->font = FontManager::getInstance()->findFont( fontName, color );
-        this->createBitmapOfLabel( this->text, this->fontName, this->color );
+        this->createBitmapLabel( this->text, this->fontName, this->color );
+}
+
+Label::Label( int x, int y, const std::string& text )
+: Widget( x, y ),
+        text( text ),
+        fontName( "regular" ),
+        color( "white" ),
+        font( 0 ),
+        buffer( 0 ),
+        myAction( 0 )
+{
+        this->createBitmapLabel( this->text, this->fontName, this->color );
 }
 
 Label::Label( const std::string& text, const std::string& fontName, const std::string& color, int spacing )
-: Widget( ),
+: Widget( 0, 0 ),
         text( text ),
         fontName( fontName ),
         color( color ),
         font( 0 ),
-        spacing( spacing ),
         buffer( 0 )
 {
-        this->font = FontManager::getInstance()->findFont( fontName, color.compare( "multicolor" ) == 0 ? "white" : color );
-        this->createBitmapOfLabel( this->text, this->fontName, this->color );
+        this->createBitmapLabel( this->text, this->fontName, this->color, spacing );
+}
+
+Label::Label( int x, int y, const std::string& text, const std::string& fontName, const std::string& color, int spacing )
+: Widget( x, y ),
+        text( text ),
+        fontName( fontName ),
+        color( color ),
+        font( 0 ),
+        buffer( 0 )
+{
+        this->createBitmapLabel( this->text, this->fontName, this->color, spacing );
 }
 
 Label::~Label( )
@@ -44,12 +64,12 @@
 {
         this->fontName = fontName;
         this->color = color;
-        this->font = FontManager::getInstance()->findFont( fontName, color.compare( "multicolor" ) == 0 ? "white" : color );
-        this->createBitmapOfLabel( this->text, this->fontName, this->color );
+        this->createBitmapLabel( this->text, fontName, color );
 }
 
 void Label::draw( BITMAP* where )
 {
+        // Dibuja la cadena en la imagen destino
         draw_sprite( where, this->buffer, this->getX (), this->getY () );
 }
 
@@ -61,53 +81,69 @@
         }
 }
 
-BITMAP * Label::createBitmapOfLabel( const std::string& text, const std::string& fontName, const std::string& color )
+BITMAP* Label::createBitmapLabel( const std::string& text, const std::string& fontName, const std::string& color, int spacing )
 {
-        // re-create buffer
-        if ( this->buffer != 0 )
+        int colorIndex(0);
+        // Colores empleados en una etiqueta multicolor
+        std::string colorFont[ ] = {  "cyan", "yellow", "orange"  };
+
+        // Se selecciona la fuente usada para representar el texto
+        this->font = FontManager::getInstance()->findFont( fontName, color.compare( "multicolor" ) == 0 ? "white" : color );
+        assert( this->font );
+
+        // Si ya está la etiqueta creada se destruye y se vuelve a crear
+        if ( buffer != 0 )
         {
                 destroy_bitmap( this->buffer );
         }
+        buffer = create_bitmap_ex( 32, text.size() * ( font->getCharWidth() + spacing ), font->getCharHeight() );
+        clear_to_color( buffer, makecol( 255, 0, 255 ) );
 
-        buffer = create_bitmap_ex( 32, getWidth(), getHeight() );
-        clear_to_color( buffer, makecol( 255, 0, 255 ) ); // magenta is “ key ” color used as transparency
+        // Número de caracteres en la cadena. No tiene porque coincidir con la longitud de la mísma
+        size_t charNum = 0;
 
-        const size_t numberOfColors = 3;
-        std::string multiColors[ numberOfColors ] = {  "cyan", "yellow", "orange"  }; // sequence of colors for multi~color labels
-        size_t colorIndex( 0 ); // index in that sequence for color of character to draw
+        // Descodificación de la cadena UTF-8
+        for ( size_t i = 0; i < text.size(); i++ )
+        {
+                std::string str = text.substr( i, 1 );
 
-        size_t charPos = 0; // position of character in the string which for utf-8 isn't always the same as character’s offset in bytes
+                if ( str.compare( "\300" ) >= 0 && str.compare( "\340" ) < 0 )
+                {
+                        str = text.substr( i, 2 );
+                        i++;
+                }
+                else if ( str.compare( "\340" ) >= 0 && str.compare( "\360" ) < 0 )
+                {
+                        str = text.substr( i, 3 );
+                        i += 2;
+                }
+                else if ( str.compare( "\360" ) >= 0 )
+                {
+                        str = text.substr( i, 4 );
+                        i += 3;
+                }
 
-        std::string::const_iterator iter = text.begin ();
-        while ( iter != text.end () )
-        {
+                // Si la etiqueta es multicolor se selecciona la fuente adecuada
                 if ( color.compare( "multicolor" ) == 0 )
                 {
-                        // pick a color for this character
-                        this->font = FontManager::getInstance()->findFont( fontName, multiColors[ colorIndex ] );
+                        this->font = FontManager::getInstance()->findFont( fontName, colorFont[ colorIndex ] );
                         assert( this->font );
-
-                        // cycle in the sequence of colors
-                        colorIndex++;
-                        if ( colorIndex >= numberOfColors ) colorIndex = 0;
+                        colorIndex = ( colorIndex == 2 ? 0 : colorIndex + 1 );
                 }
 
-                // draw this character
-                blit(
-                        this->font->getChar( text.substr(
-                                std::distance( text.begin (), iter ),
-                                incUtf8StringIterator ( iter, text.end () ) // string iterator increments here
-                        ) ),
-                        buffer,
-                        0,
-                        0,
-                        charPos * ( this->font->getCharWidth() + spacing ),
-                        0,
-                        this->font->getCharWidth(),
-                        this->font->getCharHeight()
-                );
+                // Copia del carácter a la imagen de la etiqueta
+                blit( this->font->getChar( str ), buffer, 0, 0, charNum * ( this->font->getCharWidth() + spacing ), 0, this->font->getCharWidth(), this->font->getCharHeight() );
+                charNum++;
+        }
 
-                charPos ++;
+        // Si la longitud de la cadena no coincide con el número de caracteres de la misma
+        // (caso del cirílico) entonces se ajusta el buffer al tamaño real
+        if ( charNum != text.size() )
+        {
+                BITMAP* bitmap = create_bitmap_ex( 32, charNum * ( font->getCharWidth() + spacing ), font->getCharHeight() );
+                blit( this->buffer, bitmap, 0, 0, 0, 0, bitmap->w, bitmap->h );
+                destroy_bitmap( this->buffer );
+                this->buffer = bitmap;
         }
 
         return this->buffer;
diff -Naur HeadOverHeels-f6940c2/src/gui/Label.hpp HeadOverHeels-e1d7ade/src/gui/Label.hpp
--- HeadOverHeels-f6940c2/src/gui/Label.hpp	2018-02-26 21:49:49.000000000 +0100
+++ HeadOverHeels-e1d7ade/src/gui/Label.hpp	2018-02-26 22:30:07.000000000 +0100
@@ -12,46 +12,76 @@
 #define Label_hpp_
 
 #include <string>
+#include <cassert>
 #include <allegro.h>
 
-#include "Gui.hpp"
 #include "Widget.hpp"
-#include "Font.hpp"
 
 
 namespace gui
 {
 
 class Screen ;
+class Font ;
 class Action ;
 
+/**
+ * Un texto fijo presente en la pantalla
+ */
+
 class Label : public Widget
 {
 
 public:
 
         /**
-         * Constructor
-         * @param text The text of this label
+         * Constructor. La posición de la etiqueta se establece en ( 0, 0 ), se usa la fuente
+         * por defecto y el texto es de color blanco
+         * @param text El texto a presentar
          */
         Label( const std::string& text ) ;
 
         /**
+         * Constructor. Se usa la fuente por defecto y el texto es de color blanco
+         * @param x Coordenada X de pantalla donde situar el elemento
+         * @param y Coordenada Y de pantalla donde situar el elemento
+         * @param text El texto a presentar
+         */
+        Label( int x, int y, const std::string& text ) ;
+
+        /**
          * Constructor
-         * @param text The text of this label
-         * @param fontName Name of font to draw characters
-         * @param color Color of text
-         * @param spacing Space between characters
+         * @param text El texto a presentar
+         * @param fontName Nombre de la fuente caligráfica usada para representar el texto
+         * @param color Color del texto
+         * @param spacing Espaciado entre caracteres, suma o resta tantos píxeles como se indiquen
          */
         Label( const std::string& text, const std::string& fontName, const std::string& color, int spacing = 0 ) ;
 
+        /**
+         * Constructor
+         * @param x Coordenada X de pantalla donde situar el elemento
+         * @param y Coordenada Y de pantalla donde situar el elemento
+         * @param text El texto a presentar
+         * @param fontName Nombre de la fuente caligráfica usada para representar el texto
+         * @param color Color del texto
+         * @param spacing Espaciado entre caracteres, suma o resta tantos píxeles como se indiquen
+         */
+        Label( int x, int y, const std::string& text, const std::string& fontName, const std::string& color, int spacing = 0 ) ;
+
         virtual ~Label( ) ;
 
         /**
-         * Change font and color of text
+         * Cambia el tipo de letra del texto
+         * @param fontName Nombre de la fuente caligráfica
+         * @param color Color del texto
          */
         void changeFontAndColor ( const std::string& fontName, const std::string& color ) ;
 
+        /**
+         * Dibuja el elemento
+         * @param where Imagen donde será dibujado
+         */
         void draw ( BITMAP* where ) ;
 
         /**
@@ -59,59 +89,85 @@
          */
         void handleKey ( int key ) ;
 
-protected:
+private:
 
         /**
-         * Create image of label
-         * @param text A string of characters in utf-8
-         * @param font Name of font to draw these characters
-         * @param color Color of text
-         * @return The image with magenta (key color) background and the text
+         * Crea la etiqueta sobre una imagen descodificando una cadena UTF-8
+         * @param text Una cadena de caracteres UTF-8
+         * @param font Fuente caligráfica empleada para dibujar el texto
+         * @param color Color del texto
+         * @param spacing Espaciado entre caracteres, suma o resta tantos píxeles como se indiquen
+         * @return La imagen con fondo magenta (el color clave) y el texto
          */
-        BITMAP * createBitmapOfLabel ( const std::string& text, const std::string& fontName, const std::string& color ) ;
+        BITMAP* createBitmapLabel ( const std::string& text, const std::string& fontName, const std::string& color, int spacing = 0 ) ;
 
-private:
+protected:
 
+        /**
+         * El texto de la etiqueta
+         */
         std::string text ;
 
+        /**
+         * Nombre de la fuente caligráfica de la etiqueta
+         */
         std::string fontName ;
 
+        /**
+         * Color del texto
+         */
         std::string color ;
 
+        /**
+         * Fuente caligráfica de un color específico empleada para representar el texto
+         */
         Font* font ;
 
-        int spacing ;
-
         /**
-         * Image made as composition of characters
+         * El texto de una etiqueta en pantalla se compone de muchas imágenes, tantos como
+         * caracteres tenga. Esta imagen almacena la composición para evitar volverla a
+         * realizar si el texto no cambia
          */
         BITMAP* buffer ;
 
         Action* myAction ;
 
-public:
+public: // Operaciones de consulta y actualización
 
+        /**
+         * Devuelve el texto de la etiqueta
+         * @param Una cadena de caracteres
+         */
         std::string getText () const {  return this->text ;  }
 
-        void setText( const std::string& newText ) {  this->text = newText ;  }
+        void setText( const std::string& str ) {  this->text = str ;  }
 
+        /**
+         * Devuelve la fuente tipográfica usada en la etiqueta
+         * @param Un tipo de letra
+         */
         std::string getFontName () const {  return this->fontName ;  }
 
+        /**
+         * Devuelve el color del texto
+         * @param Un color
+         */
         std::string getColor () const {  return this->color ;  }
 
+        /**
+         * Fuente caligráfica de un color específico empleada para representar el texto
+         */
         Font* getFont () const {  return this->font ;  }
 
-        int getSpacing () const {  return this->spacing ;  }
-
-        void setSpacing ( int newSpacing ) {  this->spacing = newSpacing ;  }
-
-        unsigned int getWidth () const
-        {
-                // symbols of game fonts are monospaced
-                return utf8StringLength( text ) * ( font->getCharWidth() + spacing ) ;
-        }
+        /**
+         * Devuelve la anchura de la etiqueta
+         */
+        int getWidth () const {  return this->buffer->w ;  }
 
-        unsigned int getHeight () const {  return font->getCharHeight() ;  }
+        /**
+         * Devuelve la altura de la etiqueta
+         */
+        int getHeight () const {  return this->buffer->h ;  }
 
         Action* getAction ( ) const {  return myAction ;  }
 
@@ -126,6 +182,9 @@
 };
 
 
+/**
+ * Objeto-función usado como predicado en la búsqueda de una etiqueta
+ */
 struct EqualTextOfLabel : public std::binary_function< Label*, std::string, bool >
 {
         bool operator() ( const Label* label, const std::string& text ) const;
