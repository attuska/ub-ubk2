diff -Nur orig/src/modules/chrootcfg/main.py mod/src/modules/chrootcfg/main.py
--- orig/src/modules/chrootcfg/main.py	1970-01-01 01:00:00.000000000 +0100
+++ mod/src/modules/chrootcfg/main.py	2017-11-25 19:54:58.000000000 +0100
@@ -0,0 +1,255 @@
+#!/usr/bin/env python3
+# -*- coding: utf-8 -*-
+#
+# === This file is part of Calamares - <http://github.com/calamares> ===
+#
+#   Copyright 2016, Artoo <artoo@manjaro.org>
+#
+#   Calamares is free software: you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation, either version 3 of the License, or
+#   (at your option) any later version.
+#
+#   Calamares is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with Calamares. If not, see <http://www.gnu.org/licenses/>.
+
+import os
+import shutil
+import subprocess
+import sys
+import re
+import libcalamares
+
+from libcalamares.utils import check_target_env_call, target_env_call, debug
+from os.path import join
+
+
+class OperationTracker:
+    def __init__(self):
+        self._downloaded = 0
+        self._installed = 0
+        self._total = 0
+        self._progress = float(0)
+
+    @property
+    def downloaded(self):
+        return self._downloaded
+
+    @downloaded.setter
+    def downloaded(self, value):
+        self._downloaded = value
+
+    @property
+    def installed(self):
+        return self._installed
+
+    @installed.setter
+    def installed(self, value):
+        self._installed = value
+
+    @property
+    def total(self):
+        return self._total
+
+    @total.setter
+    def total(self, value):
+        self._total = value
+
+    @property
+    def progress(self):
+        return self._progress
+
+    @progress.setter
+    def progress(self, value):
+        self._progress = value
+
+    def send_progress(self, counter, phase):
+        for p in range(phase):
+            if self.total == 0:
+                continue
+            step = 0.05
+            step += 0.95 * (counter / float(self.total))
+            self.progress += step / self.total
+
+            debug("Progress: {}".format(self.progress))
+
+        libcalamares.job.setprogress(self.progress)
+
+
+ON_POSIX = 'posix' in sys.builtin_module_names
+
+
+class PacmanController:
+    def __init__(self, root):
+        self.__root = root
+        self.__operations = \
+            libcalamares.globalstorage.value("packageOperations")
+        self.__tracker = OperationTracker()
+
+    @property
+    def tracker(self):
+        return self.__tracker
+
+    @property
+    def root(self):
+        return self.__root
+
+    @property
+    def operations(self):
+        return self.__operations
+
+    def parse_output(self, cmd):
+        cal_env = os.environ
+        cal_env["LC_ALL"] = "C"
+        last = []
+        phase = 0
+
+#        process = subprocess.Popen(cmd, env=cal_env, bufsize=1, stdout=subprocess.PIPE, close_fds=ON_POSIX)
+
+#        for line in iter(process.stdout.readline, b''):
+#            pkgs = re.findall(r'\((\d+)\)', line.decode())
+#            dl = re.findall(r'downloading\s+(.*).ubk.uhu', line.decode())
+#            inst = re.findall(r'Unpacking(.*)\.\.\.', line.decode())
+
+#            if pkgs:
+#                self.tracker.total = (int(pkgs[0]))
+#                debug("Number of packages: {}".format(self.tracker.total))
+
+#            if dl:
+#                    if dl != last:
+#                self.tracker.downloaded += 1
+#                    phase = 1
+#                    debug("Downloading: {}".format(dl[0]))
+#                    debug("Downloaded packages: {}".format(self.tracker.downloaded))
+#                    self.tracker.send_progress(self.tracker.downloaded, phase)
+
+#                last = dl
+#                elif inst:
+#                self.tracker.installed += 1
+#                phase = 2
+#                debug("Installing: {}".format(inst[0]))
+#                debug("Installed packages: {}".format(self.tracker.installed))
+#                self.tracker.send_progress(self.tracker.installed, phase)
+
+
+#        if process.returncode != 0:
+#            return process.kill()
+
+        return None
+
+    def install(self, local=False):
+        args = ["apt-get"]
+        cmd = args + self.operations["install"]
+        self.parse_output(cmd)
+
+class ChrootController:
+    def __init__(self):
+        self.__root = libcalamares.globalstorage.value('rootMountPoint')
+        self.__requirements = \
+            libcalamares.job.configuration.get('requirements', [])
+        self.__emptyfiles = \
+            libcalamares.job.configuration.get('emptyfiles', [])
+
+    @property
+    def root(self):
+        return self.__root
+
+    @property
+    def requirements(self):
+        return self.__requirements
+
+    @property
+    def emptyfiles(self):
+        return self.__emptyfiles
+
+    def make_dirs(self):
+        for target in self.requirements:
+            dest = self.root + target["name"]
+            if not os.path.exists(dest):
+                debug("Create: {}".format(dest))
+                mod = int(target["mode"], 8)
+                debug("Mode: {}".format(oct(mod)))
+                os.makedirs(dest, mode=mod)
+
+    def make_emptyfiles(self):
+        for target in self.emptyfiles:
+            uresfile = self.root + target["name"]
+            open(uresfile, 'a').close()
+
+    def chrootinit(self):
+        global  chrootdir, apt_options, dpkg_options, installcmd, pkgs
+        chrootdir = self.root
+        # Változók az apt működéséhez szükséges csomagok feltérképezéséhez
+        minpkgs = "uhu-base apt dpkg diffutils findutils"
+        statusdir = "/var/lib/dpkg/status"
+        empty_statusdir = "/var/lib/dpkg-empty/status"
+        statedir = "/var/state/apt"
+        cachedir = "/var/cache/apt"
+        apt_statdir = " -o Dir::State::status=" + chrootdir
+        apt_statusdir = apt_statdir + statusdir
+        apt_empty_statusdir = apt_statdir + empty_statusdir
+        apt_chrootdir = " -o DPkg::Options::=--root=" + chrootdir
+        apt_statedir = " -o Dir::State=" + chrootdir + statedir
+        apt_cachedir = " -o Dir::Cache=" + chrootdir + cachedir
+        apt_noimmconf = " -o APT::Immediate-Configure=false"
+        apt_farok = apt_chrootdir + apt_statedir + apt_cachedir
+        apt_farokcucc = apt_farok + apt_noimmconf
+        apt_empty_options = apt_empty_statusdir + apt_farokcucc
+        apt_options = apt_statusdir + apt_farokcucc
+        dpkg_options = " --root=" + chrootdir
+        installcmd = "apt-get " + apt_options + " --yes --force-yes install "
+
+        # Igazi és üres dpkg adatbázis létrehozása
+        # Hibakezelés kell még!
+        os.system("apt-get " + apt_empty_options + " update")
+
+        # Mely csomagok kellenek? Kiíratás egy ideiglenes fájlba.
+        tmpcmd1 = "apt-get " + apt_empty_options + " --no-act install "
+        tmpcmd2 = " | grep " + "'^Inst ' | cut -d' ' -f2 > /tmp/tmpfile"
+        os.system(tmpcmd1 + minpkgs + tmpcmd2)
+
+        # kiolvassuk a tmpfile tartalmát a pkgs listaváltozóba.
+        pkgs = [line.rstrip('\n') for line in open('/tmp/tmpfile')]
+        # Nem kell többé a tmpfile
+        os.system("rm -f /tmp/tmpfile")
+        # Na, most telepíthetünk és konfigurálhatunk mindenkit, aki kell.
+        # Hibakezelés kell még!
+        return chrootdir, apt_options, dpkg_options, installcmd, pkgs
+
+    def chrootbuild(self):
+        for pkg in pkgs:
+            os.system(installcmd + pkg)
+            # postinst
+            os.system("chroot " + chrootdir + " /sbin/uhu-pkg postinst +")
+
+    def chroot_apt_clean(self):
+        os.system("rm -rf " + chrootdir + "/var/lib/dpkg-empty")
+        os.system("dpkg " + dpkg_options + " --clear-avail")
+
+    def prepare(self):
+        cal_umask = os.umask(0)
+        self.make_dirs()
+        self.make_emptyfiles()
+        path = join(self.root, "run")
+        # debug("Fix permissions: {}".format(path))
+        os.chmod(path, 0o755)
+        os.umask(cal_umask)
+
+    def run(self):
+        self.prepare()          # Chroot alapozás
+        self.chrootinit()       # Chroot telepítési előkészületek
+        self.chrootbuild()      # Chroot telepítése
+        self.chroot_apt_clean() # Végső simítások
+        return None
+
+def run():
+    """ Create chroot and install apt """
+
+    targetRoot = ChrootController()
+
+    return targetRoot.run()
